管道和重定向
计算机组成：CPU(运算器、控制器)、存储器(RAM)、输入设备\输出设备、程序
地址总线：内存寻址
数据总线：传输数据
控制总线：控制指令
寄存器：CPU暂时存储器
I/O：硬盘、数据交互
系统设定：
  默认输出设备：标准输出STDOUT,1
  默认输入设备：标准输入STDIN,0
  标准错误输出：STDERR，2
  标准输入：键盘
  标准输出和错误输出：显示器
  
I/O重定向(Linux):
> :输出重定向，会覆盖原有内容(覆盖输出)
>> :追加输出
set 内置命令，man手册查一下，很重要
set -C :禁止对已经存在文件的文件使用覆盖重定向
set +C :允许对已经存在文件的文件使用覆盖重定向
2> :重定向错误输出
2>> :追加方式重定向错误输出
  例如：ls /var > /tmp/var4.out 2> /tmp/err.out
  (意思：如果重定向信息流正确，则输出到/tmp/var4.ou，否则输出到/tmp/err.out)
&> :重定向标准输出或错误输出至同一个文件中
< :输入重定向
<< :Here Document
  例：cat >> /tmp/myfile.txt << EOF(结束符)  可以在脚本中生成文档

管道：命令也可以使用管道，以“ | ” 为传递，前一个命令的输出可以作为后一个命令的输入
    例如：命令1 | 命令2 | .........
    例如:echo "HELLO WORLD." | tr 'a-z' 'A-Z'
tee 命令：一个输入，两个输出，用来既保存重定向，又显示在屏幕上
  练习：
  1.统计/usr/bin/目录下的文件个数
  答：ls /usr/bin | wc -l
  2.取出当前系统上所有用户的shell，要求每种shell只显示一次，并且按照顺序排序
  答：cut -d: -f7 /etc/passwd |sort -u
  3.思考如何显示/var/log目录下每个文件的内容类型
  答：file /var/log/*
  4.取出/etc/inittab文件的第6行
  答：head -6 /etc/inittab | tail -1
  5.取出/etc/passwd 文件中倒数第9个用户的用户名和shell，显示到屏幕并保存到/tmp/users 中
  答：tail -9 /etc/passwd |head -1 | cut -d: -f1,7 | tee /tmp/users
  6.显示/etc目录下所有以pa开头的文件，并统计其个数
  答：ls -d /etc/pa* | wc -l        (不加-d 就会把目录下的子文件也显示了)
  7.不使用文本编辑器，将 alias cls=clear 一行内容添加至当前用户的.bashrc 文件中
  答：printf "alias cls=clear" >>~/.bashrc
----------------------------------------------------------------------------------------
    grep及正则表达式：
文本查找的需要：grep、egrep、fgrep
grep命令：使用基本正则表达式定义的模式来过滤文本的命令
grep:Global Research (根据模式搜索文本，并将符合模式的文本行显示出来，是局部匹配),可加选项
Pattern:模式，有文本字符和正则表达式的元字符组成而成匹配条件
用法：grep [option] pattern [file .....]
    -i:忽略大小写
    --color:加颜色显示
    -v:显示没有被模式匹配的行
    -o:只显示被模式匹配的字符
    -E：使用扩展正则表达式
    -A #:跟数字，表示显示搜到的字符连同其后几行一起显示
    -B #:跟数字，表示显示搜到的字符连同其前几行一起显示
    -C #：跟数字，表示显示搜到的字符连同其前后几行一起显示
    
正则表达式：Regular Expression,简写REGEXP
元字符：
 . ：匹配任意单个字符
 [] ：匹配指定范围内的任意单个字符，[^]则是范围外的
 字符集合：[:digit:]、[:lower:]、[:upper:]、[:punct:]、[:space:]、[:alpha:]、[:alnum:](使用时还要再加[] ,具体意思看之前的笔记)
正则表达式默认工作在贪婪模式下，它会尽可能匹配多个
匹配次数：
* ：匹配其前面的字符任意次，跟之前的‘ * ’意思不一样
  例：a,b,ab,aab,acb,adb,amnb
  匹配a*b  能匹配上有：b,ab,aab
.* :任意长度的任意字符
\？ ：匹配其前面的字符1次或0次，注意：\？ 是转义字符
\{m,n\} ：匹配其前面的字符至少m次，最多n次
    例如：grep 'a\{1,3\}b' file
    
 位置锚定：
^ ：锚定行首，此字符后面的任意内容必须出现在行首
 用法：grep '^r..t' /etc/passwd
$ :锚定行尾，此字符前面的任意内容必须出现在行尾
 用法：grep 'y$' /etc/passwd
^$ ：空白行
\b或\< :锚定词首，其后面的任意字符必须作为单词的首部出现
\b或\> :锚定词尾，其前面的任意字符必须作为单词的尾部出现

分组：
\(\) :主要作用是后向引用
 \1：以第一个左括号出现的结果作为条件
 \2：以第二个左括号出现的结果作为条件
 ....................
例如：grep '\(l..e\).* \1' test.txt
两种正则表达式：
1.Basic REGEXP(基本)
2.Extended REGEXP(扩展)
egrep 扩展正则表达式：
字符匹配：(  .   []  [^]     )
次数匹配：
    *：同之前
    ?:同之前，但是不加 " \ "了
    +：其前字符至少一次
    {m,n}：同之前，但是不加" \ "
位置锚定和之前一样：^  $  \<或\b  \>或\b
分组：
   () ：同之前，但是没有了" \ "
       \1,\2,\3 .........
   | :或者(or)
注意：fgrep 不支持正则表达式
IPV4：分为5类   A B C D E 
A: 1-127
B:128-191 
C:192-223
---------------------------------------------------------------------------
        bash脚本编程
编译器，解释器--->由静态语言开发
编程语言：机器语言、汇编语言、 高级语言
静态语言：编译型语言
        1.强类型（变量）           2.关键字
        3.事先转换成可执行格式     4. C、C++、Java、C#
动态语言：解释型语言
        1.弱类型                  2.边解释边运行
        3.PHP, SHELL, Python, per(面向过程), Lua
面向过程：shell、C
面向对象：Java 、Python 、perl、C++
变量：内存空间,命名
内存：编址的存储单元
bash变量类型：
  1.环境变量：作用域为当前shell进程及其子进程
      export VARNAME=VALUE
  2.本地变量：作用域整个bash进程
      VARNAME=VALUE
      局部变量：作用域于当前代码段
      local VARNAME = VALUE 
  3.位置变量
      $1,$2.........
  4.特殊变量
      $?:上一个命令的执行状态返回值
      程序执行，可能有两类返回值
            1.程序执行结果
            2.程序状态返回代码(0-255)  
                0：正确执行
                1-255：错误执行
                1，2，127为系统保留，其他可以自行定义
引用变量：$(VARNAME),括号有时可以省略，只要NAME后面不跟其他字母导致识别不出来
脚本在执行时会启动一个字shell进程
      1.命令行中启动的脚本会继续当前shell环境变量
      2.系统自动执行的脚本(非命令行启动)就需要自行定义需要的各环境变量
/dev/null:软件设备，bit bucket ,数据黑洞
撤销变量：
  unset VARNAME
查看当前shell中的环境变量：printenv、env、export   （任选一）
脚本：命令的堆砌，按实际需要，结合命令流程控制机制实现的源程序
    shebang： 魔数
    例{  #！/路径       （脚本第一行必须写，前面有空白行都不行，例如 #! /bin/bash）    } 
      #  注释掉，第一行是特例
条件测试类型：整数测试、字符测试、文件测试
条件测试的表达式(expreesion)：
    [expression]     命令测试法
    [[expression]]   关键字测试法
    test expression
    例：[ $A -eq $ $B ],有必须有空格
 整数比较：
      -eq:测试两个整数是否相等，比如: $A -eq $B
      -ne:测试两个数是否不等，不等为真，相等为假
      -gt:测试一个数是否大于另一个数，大于为真，否则为假
      -lt:测试一个数是否小于另一个数，小于为真，否则为假
      -ge:测试一个数是否大于或等于另一个数，大于或等于为真，否则为假
      -le：测试一个数是否小于或等于另一个数，小于或等于为真，否则为假
命令间的逻辑关系：
  逻辑与：&&
    第一个条件为假时，第二个条件不用再判断，最终结果已经有了
    第一个条件为真时，第二个条件必须再判断
  逻辑或：||
    第一个条件为假时，第二条件再判断
    第一个条件为真时，第二条件不再判断
 变量名称命名规则：
    1.只能包含字母，数字和下划线，并且不能以数字开头
    2.不应该和系统中已有的环境变量重名
    3.最好做到见名知义
 显示系统中有多少个用户：
      {   USER=`wc -l /etc/passwd | cut -d: -f 1`
           echo  "$USERS users."              }
 判断是否创建用户：
      {！id user | &> /dev/null &&useradd user1 && echo "user1" | passwd --stdin user1 &> /dev/null || echo "user1 exists."}
 ---------------------------------------------------------------------------------------------------------------------------
 条件判断，Linux中  0为真，1为假
 单分支if语句：
      if 判断条件;then
          语句1
          语句2 
          .......
      fi   (结束符)
  
  双分支的if语句：
       if 判断条件；then
           语句1
           语句2
           ..........
       else 
           语句1
           ..........
        fi  (结束符)
取用户的UID：id -u username

练习：
    问题一：判断当前系统上是否有用户的默认shell为bash,如果有，就显示有多少个这类用户；否则就显示没有这类用户。
    {  #! /bin/bash
       #
       grep "\<bash$" /etc/passwd &> /dev/null
       RETVAL=$?
       if[$RETVAL -eq 0] ;then
          grep "\<bash$" /etc/passwd | wc -l 
       else
          echo "No scuh user"
       fi
      }
      
    问题二：判断当前系统上是否有用户的默认shell为bash,如果有，就显示其中一个用户；否则就显示没有这类用户。
      {  #! /bin/bash
       #
       grep "\<bash$" /etc/passwd &> /dev/null
       RETVAL=$?
       if[$RETVAL -eq 0] ;then
       AUSER=`grep "\<bash$" /etc/passwd | head -1 | cut -d: -f1
       echo "$AUSER is one of such users."
       else
          echo "No scuh user"
       fi
      }
----------------------------------------------------------------------------------------------------
shell 中如何进行算术运算
1.let 算术运算表达式，具体查man 手册
   例如：A=3
        B=6
        let C=$A+$B
2.$[算术运算表达式]
  例：C=$[$A+$B]
3.$((算术运算表达式))
  例：C=$(($A+$B))
4.expr 算术运算表达式 ,表达式中各操作数及运算符之间要有空格，而且要使用命令引用
  C=`expr $A + $B`
